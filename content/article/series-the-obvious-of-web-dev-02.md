---
title: "Web開発技術のあたりまえ 2 - 「Web開発技術」って何だろう -"
date: 2023-11-19
toc: true
series:
  - 'Web開発技術のあたりまえ'
categories:
  - 'Web開発技術のあたりまえ'
  - 'Develop'
  - '勉強会'
draft: false
math: true
---

## 解像度を上げてみよう

---

> 語りえぬものについては、沈黙しなければならない。  
> — _Ludwig Josef Johann Wittgenstein_[^1]

[^1]: [『論理哲学論考』](https://ja.wikipedia.org/wiki/%E8%AB%96%E7%90%86%E5%93%B2%E5%AD%A6%E8%AB%96%E8%80%83)より。

---

「はじめに」で述べた通り、「あたりまえ」とは特定の事象に対して複数の人間が持つマインドモデルが一致している状態のことを指す。  
特定の事象に対して人間の内面が完全に一致するのは不可能だ。そこで、普通は規範となるべき質の高いモデルを選定し、その合意や理解、実践によって規範的モデルとしたり、その集団において適切な形になるようにモデルをカスタマイズしたりする。特にシステム開発においては、このような「あたりまえ」の作られ方が非常に多い。

ただ、ベースとなる規範的モデルを選ぼうにも、Web開発技術のモデルを選定しようとするとその時点で足が止まることも多々ある。

それも当然で、Web開発技術、もといシステム開発は多数の要素が絡み合い成立している複雑系であり、そもそも一見で理解することは難しいからだ。  
さらに言えば、複雑系を説明するモデルも、人類の知識の一部である以上、ある別のモデルにおける語彙や知識を前提としていることが多い。その界隈で一般的に使われる語彙の意味解説が省略されていたり、その業界では当然であるべきものの説明が省かれていたりすることもしばしばある。

以上から、Web開発技術における規範的モデルを選出するためには、モデル同士に共通する要素を認識するだけでなく、モデルが成り立つために必要である、業界で一般的な基盤知識も必要になるだろう。

モデルはどのような事象をどのような観点から切り抜いて見たのか、モデルを取り巻く基盤の知識にはどのようなものがあるか……等々、Web開発技術のモデルを見る上で知るべきことはいろいろとあるが、まず初めにモデルにおいて必要な「何についてのモデルか」という部分、つまり「Web開発技術」という大枠とは何かから始めていこう。

---

### Web開発技術とは何を指すのか

Web開発技術は、システム開発においてもはや触れないで進めることが不可能となるほど巨大な技術体系だ。ほとんどのシステムは、なんらかの形でWeb開発技術を利用しているといっても過言ではない。

このWeb開発とは何なのか、ものすごく乱暴に言ってしまうと **「Webブラウザ上で動くアプリケーションを作る」** ことだ。  
では、Web開発技術とは「Webブラウザ上で動くアプリケーションを作るための技術」のことかと言うと、実は少しだけニュアンスが違う。  
**Web開発技術は、主にWeb開発で使われる技術である** のは間違いないが、**その技術はWeb開発以外にも利用可能だ。** *Technologies for Web Development* ではなく、 *Technologies commonly used in Web Development* である、と英語で表現すると、なんとなく伝わるだろうか。

例を挙げると、*JSON*なんかが代表的だろう。これはブラウザ上で非同期通信と画面更新を行う技術……いわゆる*Ajax*の普及とともに広まったデータフォーマットで、*JavaScript*のオブジェクトに由来する一定の形式をもった文字列を表す。  
*JSON*は*JavaScript*のみならず、プログラム言語で利用される構造化されたオブジェクトの形を模したものであり、読みやすく、メモリ上のデータに展開しやすいという特徴から、現代では様々なプログラム言語間でデータを共有するフォーマットとして利用されている。これは後述する *Web標準(Web Standard)* の一部であるが、用途はWeb開発に限らず、スタンドアローンで動くプログラムの設定記述フォーマットとしても使われることがある。

加えて、現代はSaaS[^2]の普及により、Webでデータを相互利用するビジネスを実現したいという要求は多いし、今までdllなどのコンパイルされた形式で提供されてきたライブラリが提供元の都合ですべてWeb APIを経由した機能提供に変わったり、組み込み分野でもIoT[^3]を求められるなんてこともあり得るだろう。

**Web開発技術は、システム開発に関わる限り、もはや必須のものとなっている。**  
**今まではブラウザを扱うアプリケーション開発におけるあたりまえであったものが、今やシステム開発に関わるもの全員のあたりまえとして扱われるべき、という世界になっているのだ。**

[^2]: *Software as a Service* の略称。パッケージングされた複数の機能を持つアプリケーションやソフトウェアを、全ての機能が揃った形で納品するのを旧来のものとしたとき、アプリケーションが持つ特定の機能だけを提供する形態のサービスのこと。たとえば、AWSというクラウドプラットフォームを一つの製品として捉えた時、ユーザーはAWSのすべてのサービスに金を払う必要はなく、EC2などのAWS内で提供されている特定サービスの利用料に応じて金を払う。現代でインターネットを通じて提供され、使用プランを選択できるブラウザベースのWebサービスは、ほぼほぼSaaSもしくはXaaS( *X as a Service* 一つの目的を達成するパッケージングではなく、機能を提供する形態全てを差す)であると言っても過言ではない。

[^3]: *Internet of Things* の略称。モノのインターネットとも呼ばれる。インターネットを通じて、ブラウザなどから現実世界に存在する物を操作するリモートコントロールの総称だが、ここにはWeb技術由来の技術が使われている。

---

{{< figure src="https://asset.watch.impress.co.jp/img/iw/docs/1107/574/001.png" width="640" title="図 2-1. スマートスピーカーの世界にブラウザは無いが、構成を見ると、インターネットの仕組みを利用したWebサーバーのようになっている。" caption="[Internet Watch /『呼び掛けにどう応答しているのか？　Amazon EchoやGoogle Homeが動く仕組み』](https://internet.watch.impress.co.jp/docs/column/nettech/1107574.html)より画像引用。">}}

---

### 「広さ」の深堀：Web開発技術についてのモデルの細かなカテゴライズ

Web開発技術と一言で言っても、すべてを把握するのは大変だ。  
Web開発技術という言葉で人が想像するものは多岐にわたるし、そもそも技術体系という広範なものを一見で理解することは難しい。

それでもなお人がモデルを作り出すとき、人は「焦点」と「分類」と呼ばれるものを使ってきた。語るべきものと語らないものについて分け、語るものについてはどのような立場から見て言ったものかを明らかにし、必要なもののみを抜き出す。そして、そうやって抜き出した必要なものを、ある一つの言葉でひとまとめにして、簡単に扱えるようにしていく。

この節では、「Web開発技術」という大きな体系に対し、概ね人はこうやって「Web開発技術」を分類し、切り取って扱っているであろうという話をする。  
僕が開発者としてモデルを学んできた中で考えてきたことの一つに、「Web開発技術について人がモデルを示すとき、概ね全体のことではなく、あるカテゴリについて観点を置いている」というものがある。これはそういったモデルの焦点、および多くの人に共通するカテゴリの分け方の観測結果について示したものだ。

ざっくりと挙げても、Web開発技術において知るべきとされる要素のカテゴライズや、現実を切り取るときの切り口……つまり、僕のメタモデルの構成要素には以下のような知識群がある。

- **インターネットプロトコルとWeb標準**
- **ユーザーエージェントについての知識**
- **データ構造とアルゴリズム**
- **プログラミング**
- **プログラミングパラダイム**
- **システム開発のメソドロジー**
- **プラクティス**
- **ライブラリ**
- **ツール・ツールチェーン**
- **主要なWebシステムのソフトウェアアーキテクチャパターン**
- **エコシステムとテクノロジースタック**
- **フレームワーク**
- **トレンド**

……かなり盛りだくさんだ。だが、これらのカテゴリに含まれる詳細な要素はともかく、カテゴリ自体について避けて通ることはできない。  
単語を挙げただけでは僕自身のマインドモデルは伝わらないと思うので、大まかな学習領域に分けながら少しずつ説明していこう。

---

#### ■ Webを支える技術
**インターネットプロトコル**、**Web標準**、**ユーザーエージェントについての知識**がこの領域に当たる。  
この領域はインターネットやWebが成り立つための基盤体系だ。すべてを覆すような技術革新でも起こらない限り、完全に変化することはないだろう。  
とはいえまったくもって変わらないというわけではなく、時代によって小さな変化を繰り返し、便利になっている部分や非推奨とされるものも出てくるため、そういった小さな変更点に触れるような情報もしばしば出回る。

インターネットはコンピュータ同士をつなぐための世界的な通信網だ。だが、二者間の秘密通信だけで世界が成立するならまだしも、通信網を使って世界中の様々なコンピュータ同士で通信を行うためには、どのような通信をどうやって受け取るか（また、どうやって危険なものを受け取らないようにするか、秘密にしたい通信を秘密にするか）というルールが必要となる。この領域は、そんな世界共通の約束を扱うものだ。

**インターネットプロトコル** :  
情報工学や厳密な定義を問う世界であればより詳細な定義が必要だが、ここでは **IPアドレス** というネットワーク上の住所のようなものを使った通信の仕組み全般のことを指す。  
このシリーズでは、ほとんどの場合 *TCP/IP* と呼ばれるインターネットプロトコルの集合に含まれるものを対象としている。

**Web標準(Web Standards)** :  
インターネットは世界的な通信網のことを指すが、Webはインターネットという基盤を使ったドキュメントやコンテンツのやりとりを構成する世界的なシステムのことを指す。このWebで扱う通信・ファイルの規格や技術仕様、より良いコンテンツの提供の仕方などを定めたのがWeb標準となる。Webのドキュメントを取得・表示するアプリケーションの代表がWebブラウザのため、実質的に様々なWebブラウザの共通仕様となっている。  

この分野に関して注意点がある。Web標準というものを勧告している団体は一つではなく、「Web標準」という名前の決まった一つのドキュメント体系があるわけではないという点には気を付けてほしい。

狭義のWeb標準は[World Wide Web Consortium(しばしばW3Cと呼ばれる)が出している勧告](https://www.w3.org/TR/)を指すが、[IETFというインターネット技術標準化団体の技術仕様群であるRFCの一部(STD Stage)](https://www.nic.ad.jp/ja/rfc-jp/RFC-Category.html)や、[WHATWGが提供するHTML Living Standard](https://seolaboratory.jp/49735/)、[ECMA Internationalが提供する、実質的にJavaScriptの仕様となっているECMAScript](https://ecma-international.org/publications-and-standards/standards/ecma-262/)なども含めた、多数の団体が出した様々な規約や仕様の集合を「だいたいのWebブラウザで利用可能な技術」という意味で広義のWeb標準として扱うことがある。  
個人的な観測範囲ではあるが、どちらかといえば広義の意味で使われることの方が多い。そのため、特に断りがなければ、このシリーズにおいても「Web標準」は広義のWeb標準のことを指すこととする。

これらをすべて追うのは難しく、また「これがWeb標準である」という定義があやふやなものではあるが、[後述するMDN Web Docsが氾濫するWeb開発技術を一括してまとめる試みを行っている](https://www.publickey1.jp/blog/17/googlew3cmozillawebmozillaweb.html)ため、MDN Web Docsに扱われている語彙を中心に見るのが良いだろう。

また、Web標準に該当する仕様や勧告は、おおむね提出された提案書をもとに協議を重ねWeb標準へと採用されるというプロセスを持つ。そのため、まだWeb標準レベルとして採用されていないが開発者に注目されている、という提案がいくつも出てきている（かく言う僕も、[HTTP Query Method](https://datatracker.ietf.org/doc/draft-ietf-httpbis-safe-method-w-body/)がWeb標準として採用されたら絶対に使おうと思っていたが、「便利なのはわかるけれど、GETと役割が被るし、単純なサーバー動作だけでなくミドルウェアやキャッシュ、プロキシなども動作を書き換える必要があり、影響が大きすぎるから無理」ということになっているようだ。残念）。  
新しいWebの動向チェック対象として、このような草案を見てみるのも良いだろう。

**ユーザーエージェント** :  
Webの世界では、データを取得する側とされる側が存在する。これは後述するアーキテクチャスタイルの中のクライアント・サーバーモデルと呼ばれるアプリケーションの形態であり、「クライアント」として呼ばれることも多々ある。HTTPの世界におけるクライアント、つまりデータを取得する側のアプリケーションやプログラム、およびそれらの識別子のような情報のことを指す。  
ほとんど場合はユーザーエージェントとはブラウザの種類のことだ。だが、HTTPによる通信でコンテンツのやり取りを行うアプリケーションはブラウザ以外にもモバイルアプリケーション、Webクローリングのためのプログラムなど多数存在する。こういったブラウザとブラウザ以外のアプリケーションもまとめてユーザーエージェントと呼ばれる。

この領域において規定されているものはかなり多い。一覧を見るだけでもかなりの時間を要するだろう。  
また、仕様や規約を表記したものであるためか、正直言って内容もかなり読みづらい。

僕自身は「できる限り言葉の意味や規約・仕様は原義を読め」という派閥だが、この領域に限っては別だ。  
ただし、Web上で検索可能な記事ではなく、編集や検証を経て出版された書籍や、[MDN Web Docs](https://developer.mozilla.org/ja/docs/Learn)などの大規模コミュニティで運営されているサイトなどを使って確認することを推奨する。

また、見るべき範囲に関しても、自分の対応するべき業務において利用されるユーザーエージェントに絞って見る方がいいだろう。  
例えば、あなたがモバイルアプリケーションの実装者で、モバイルアプリケーションからWeb APIにアクセスする場合、HTTPについてのWeb標準のいくつかは知るべきだが、HTMLやCSSについてのWeb標準は知らなくても業務を達成できるかもしれない。  
その場合は、ユーザーエージェントにおけるHTTPリクエストの利用法を読み、その中で出てきたわからない単語を一つずつ調べる、という「枝葉から根を辿る」アプローチが有効だ。

---

#### ■ コンピュータサイエンスとプログラム開発の基本
**データ構造**と**アルゴリズム**、**プログラミング**がこれにあたる。  
**プログラミングパラダイム**はこの領域とプロセスや考え方の領域にもまたがっていると考えていいが、詳細についてはまた後述する。

**データ構造** :  
データを情報を扱いやすくする一定のまとまりとしたとき、可視化・利用しやすくするための階層構造や、ある一定の方法で別の媒体に送りやすくするための方法論・運用手法などがある。これらをデータ構造として総称する。

**アルゴリズム** :  
何かの問題を解決するための手順・考え方・効率的な計算方法の総称。

**プログラミング** :  
データとアルゴリズムをコンピュータに認識させ、解いてもらうための行為全般のことを指す。これが可能なコンピュータ語がプログラミング言語と言える。

Web開発はソフトウェア開発の分野の一つであり、コンピュータを利用したシステムを扱うものだ。ソフトウェアである以上、どうしてもコンピュータサイエンスからは離れることができない。「Web開発をやりたいです！ところで、変数って何ですか？」というようなまっさらな知識状態だと、正直言って、この後の話は理解が難しいかもしれない（けれど、そうだとしても諦めずに読み続けてほしい）。

個人的な見解を多く含むものであるが、これはノーコード・ローコードと呼ばれる、いわゆるプログラミング言語を一切使わずソフトウェアが作れるといったツールを使う場合でも同様だ。  
これらのツールは[ビジュアルプログラミング](https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B8%E3%83%A5%E3%82%A2%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E)を扱うものであり、結局はコンピュータサイエンスを基盤にしたものである以上、なんらかのデータを順次・分岐・反復を用いたアルゴリズムに従って扱い表現するという世界から逃れることはできない。

どのようなモデルを知るのであろうと、何を規範的モデルにするのであろうと、最低限の知識基盤は必要になる。この最低限の知識基盤は行うべき業務や目的、職責によって違うものではあるが、例えばコードを扱う開発者であれば「FizzBuzz問題を解き、解いた結果を逆順に再度出力する[^4]」ということができる程度には、なんらかのプログラミング言語、およびデータ構造についての知識習得は必要だと思う。[^5]

[^4]: https://ja.wikipedia.org/wiki/Fizz_Buzz による順次・反復・条件分岐の把握、および連結リストや配列の利用・データ格納と標準出力へのアクセスができるかどうかを見る簡単なテストとして想定。言語によっては標準入力からの型変換や変換検証も含む。

[^5]: この点は諸説ある。ライブラリやソフトウェアがうまく実装を隠蔽し、抽象化されたインターフェースでプログラムを扱えるようになった現代では、普遍的なアルゴリズムやデータ構造を深く知らなくとも開発はできるという人もいれば、スタックやキュー、ツリーのようなデータ構造が説明可能で、貪欲法などの頻出アルゴリズムがある程度理解できているのはあたりまえであってほしい、という人もいると思う。僕はどちらかというと前者寄り（人のマインドモデルを一致させ、知識習得を促すコストよりも、富豪的にコンピューティングリソースを使ったり、「内部的にどうやって目的を達成するのかはわからないが、とにかく目的を達成できる」ようなライブラリを使った方が総合的なコストは安いという立場）だ。だがそうであっても、ある一定の段階からは必ずアルゴリズムやデータ構造軽視によるパフォーマンスやセキュリティの痛みが発生するため、データ構造とアルゴリズムを知っていかなければ越えられない壁がいつかは出てくる（あるいは、誰かにその負担を押し付けてしまう）、という認識でいる。よって、データ構造とアルゴリズムを最初の一歩を踏み出すときの壁として扱うことはせず、定期的に少しずつ拾い集めるのが最善の方法であると考え、あくまでスタートラインとして機能するラインを提示した。よって、最低限開発者としてできていなければいけないハードルとしてはかなり低いものを置いている。

---

#### ■ 考え方とプロセス
**プログラミングパラダイム**と**システム開発のメソドロジー**、そして**プラクティス**はこの領域となる。

**プログラミングパラダイム** :  
プログラミングおよびプログラム言語の利用を支える思想や考え方、捉え方のこと。プログラミングに対する哲学の流派、と考えてもいいかもしれない。これはプログラミング言語の書き方・作り方と言った方法論や、良いプログラム・システムの作り方とはどのようなものと考えるか、どのような課題を解決したいのかと言ったものも含む。有名なところで言うと、「オブジェクト指向プログラミング」などが挙げられるだろう。

**システム開発のメソドロジー** :  
「システム開発手法」と言い換えた方が多くの人に馴染みがあるだろう。あるいは、「ウォーターフォール」のような具体例の方がわかりやすいかもしれない。システムの作成には多くの人が絡み、一人にだけわかるような手順でプログラムを書くだけでは完成しない。システムとして完成させるために、特定のステップを定め、それに従っていくことで成功に近づいていく。こういった方法論や試みがメソドロジーである。

**プラクティス** :  
プログラミングパラダイムにもメソドロジーにも関わるもので、日本語で「慣習」と言い換えてもいい。特定の考え方や手法に従ってシステム開発を行っていったとき、往々にしてパラダイムやメソドロジーなどの概念・大きな枠組みではどうするべきかというHowが詳細に明示されていないことがある。  
そういった小さな領域で採用・実践していくとパラダイムやメソドロジーに沿った良い効果がある方法論・パターンのことを指す。パラダイムやメソドロジーは、このプラクティスの集合や連携とセットで語られることが多い。

これら3つをひとまとめにしたのには理由がある。この3つは、**モデルの構成要素として扱うときに特に注意が必要な領域だ。**  
というのも、こういった複雑系を簡単にとらえるために一言で説明される考え方やプロセスは、得てして独自の定義に化けやすく、その効果が有効になる前提や背景があやふやになりやすいからだ。

「オブジェクト指向プログラミング」というプログラミングパラダイムを例に取ろう。オブジェクト指向プログラミングとは、継承とカプセル化とポリモーフィズム（多態性）をうまいこと使ってプログラムを作ると、なんかいい感じのプログラムができて、`bark()`というメソッドを持つ`Animal`抽象クラスを継承した`Dog`や`Cat`の実態クラスを作ると鳴き声を変えられて多態性が実現できるとかどうとか説明されるアレである。  
僕はいわゆるオブジェクト指向プログラミングを実現できると謳われている*Java*というプログラミング言語を使って仕事をしているが、正直言ってこの説明がオブジェクト指向プログラミングを説明しているとは思わない。しかし、これはたしかにオブジェクト指向プログラミングの説明なのだ。……どういうことだろうか？

詳しい定義や経緯はかなりの量の説明が必要になってしまうので省くが、「オブジェクト指向」と呼ばれるモデルが歴史上いくつか存在し、それらが統合されたり分岐されたりを繰り返し、誰かのマインドモデル化とモデルとしての表出を繰り返した結果、様々な「オブジェクト指向」の特徴を持つ独自の「オブジェクト指向」が構築され、それを*Java*および*Java*の記法を模した言語で実現するための方法論が、しばしば語られる「*Java*っぽい特徴の独自のオブジェクト指向（*Javaject指向*なんて言う人もいる）」になっている[^6]。というのが僕の理解だ。

[^6]: 「ストラウストラップ アランケイ オブジェクト指向」でGoogle検索して、この二人の功績に触れたオブジェクト指向に関する記事を探してみると良い。「オブジェクト指向」というバズワードがいかに異なる意味の同じ言葉として扱われてきたかわかる。

システム開発において、このような原義とは異なるパラダイムやメソドロジーを採用し、しかし、それが原義とは異なるとは誰も気付いていないということは多い。時には、毒にも薬にもならない、ただ面倒なだけの半端な独自方式が採用されていることもある。  
それにもかかわらず、 **原義とは異なる定義の考え方や進め方が、「あたりまえ」として扱われることが多々ある。** これはパラダイムやメソドロジーが本来持つ強みを生かすことなく、しかも新規参入者にはわかりにくいという不幸の再生産を作りやすい。

加えて、パラダイムやメソドロジーには、発案当時の状況において有効だったが今になっては時代遅れになってしまったものも多々あるため、時代背景にも気を配る必要がある。例えばオブジェクト指向（として現在扱われている、例の三大要素のパラダイム）における継承は、現代のプログラミング言語機能やツール群を利用した開発においては、メリットよりもデメリットの方が多いというのが近年の定説となっている。

これらを踏まえて注意点を明確にすると、**規範的モデルは要素を入れ替えてカスタマイズされるべきだが、規範的モデルを構成する要素そのものの意味を変えて使ってはならない。** ということになる。この領域は特に要素の意味の取り違いが起こりやすい。

名前がついているものには、それ相応の経緯と前提となる情報が凝縮されている。特に長年使われているものならなおさらだ。  
この領域の要素を適切に扱うためには、とにかく原義・経緯・現在の動向や評価という3つの視点を重視することだ。  
そして、可能な限り「あたりまえ」とされているパラダイムやメソドロジーを、用語やプラクティス、解決しようとしていた課題などに分解し、見直しを行い、原義と異なる要素を少しずつ抽出していくことが必要だ。

「あたりまえ」を捉える時、対象についての知識をすぐ揃えるのはほぼ不可能に違いが、「我々はオブジェクト指向プログラミングを行っています（あるいはドメイン駆動開発やスクラムといった、ある種流行に乗った方法論や考え）」という「一言で我々を説明する系」の言葉が出た時に、それが原義通りなのかどうかを少し疑ってかかり、真に原義と一致している部分はどれだろうと考えたり、考え方のズレを適切に議論するのが良いだろう。

「Web開発技術のあたりまえ」というタイトルにおいて、「考え方やプロセス」という項目で知るべきものは、実はこれがすべてだ。  
「オブジェクト指向というパラダイムや、関数型というパラダイムがあり、このパラダイムはこういった特徴を持っていて……」といった風に、パラダイムやメソドロジー一つ一つについて詳細に知ることをするつもりは無いし、そのうちどれかを「当然知っているべき技術」として扱うつもりは無い。というか、もし書くのならば僕は少なくともあと半年はこの文章を書くのに費やす必要がある。

現代のWeb開発技術、およびそれに付随する考え方の変化や発展はとにかく早いし、ある情報に対する解説コンテンツの広がりの速度はどんどんと増している。となれば、オブジェクト指向に起こったような言葉の意味のキメラ化や、時代に合わないプラクティスの顕出、そしてそれを改善した発展的な新たな考え方やプロセスの出現も、どんどん早いサイクルで為されることが予想される。人によって意見が違うこともあるため、様々な人のポジションや考え方を考慮したうえで原義を再解釈しなければならない事態も出てくるだろう。

プログラミングパラダイム・メソドロジー・プラクティスという単語の使い分けと、「色んな人や書籍から学び、歴史と今を見て、実際の自分の周囲での使われ方と比較して、定期的にみんなで見直すことを継続的に続ける」という最重要知識(と、あとは、出てきた単語をGoogleで調べられるくらいのちょっとの検索力と英語翻訳のツール)さえわかれば、「Web開発技術のあたりまえ」として伝えるべきこととしては十分だろう。もちろん、色んなパラダイムやメソドロジーを熟知し、集団や環境に合った良い方法を提供できることができればもっと素晴らしいということも伝えておこう。

---

#### ■ 再利用と組み合わせの技術

Web開発技術の花形でもあり、多くのモデルにおいて語られている領域がここだ。  
個別具体のテクノロジーや実体験と強く結びつくものが多いため、経験者にとって書きやすく、読みやすいものが多い。

**ライブラリ** や **ツール・ツールチェーン**、**エコシステム**、**ソフトウェアアーキテクチャパターン**、**テクノロジースタック**、**フレームワーク**がここに該当する。

**ライブラリ** :  
特定の機能を達成するために作られた、小さなプログラムの部品のことを指す。  
単独ではアプリケーションとしては機能しないが、アプリケーションを作る際には多数のライブラリを利用してアプリケーション機能を達成することが多い。

なお、画像ファイルなど、プログラムとして実行されるわけではないが、プログラム内に組み込まれてユーザーに提供されるものは、ライブラリではなく「静的ファイル(Static File)」や「アセット(Asset)」と呼ばれる。

**ツール** :  
ライブラリが建築で使われる釘のような部品だとしたら、ツールはそれを打ち込むための金槌だ。  
提供されるソフトウェアに直接組み込まれるわけではないが、そのソフトウェアを作るために大きな役割を果たすアプリケーションやプログラムのことを指す。

大小問わず、ソフトウェア開発者は様々なツールを使う。IDE(統合開発環境)といったグラフィカルUIの大きなツールから、「はじめに」で触れたトランスパイラのようなコマンドラインUIの小さな機能のツール、そして、ツールの機能を拡張するためのツールであるプラグインなど、様々な規模や形態のものが存在している。

**ツールチェーン** :  
特定の目的を果たすためのツールの連携・連鎖のこと、また、その際に利用されるすべてのツールのこと。  
特にソースコードを実行可能な形式にする「ビルド」と呼ばれる作業に使うツール連携に対してツールチェーンという言葉を使うことが多い。

ビルドは内部的にはコンパイラやリンカといったツールによって様々な処理を行っているが、現代においてはこれらの処理は隠蔽され、なんらかのコマンドやGUIによる呼び出しで隠蔽されている。このように、ツールチェーンは隠蔽され、抽象化された呼び出し方法により実行されることがほとんどである。

……が、フロントエンド、特にJavaScriptのツールチェーンは、小さなツールの組み合わせを利用者が考えて作り上げることが「あたりまえ」とされてきた経緯があり、[ここ数年は独自のツールチェーンが跋扈し、かなりの混沌の様相を見せていた](https://medium.com/@hiroshitakeuchi/2016%E5%B9%B4%E3%81%ABjavascript%E3%82%92%E5%AD%A6%E3%81%B6%E3%81%A8%E3%81%93%E3%82%93%E3%81%AA%E6%84%9F%E3%81%98-b969f5767d7c)。[現代ではこれらのツールチェーンを統合しようという試みも出てきているが](https://zenn.dev/akfm/articles/6d62560e1273c6)、それでもまだ完全に定まっているとは言い切れない状況にある。(なんならリンク先にある統合ツールチェーンを構築するツールである*Rome*すらも、プロジェクトとしては停止しており、[2023年では*Biome*という後継ツールに後を託すことが決定した](https://codezine.jp/article/detail/18266))

**エコシステム** :  
エコシステムはもともとは生態学の研究からきた言葉で、日本語では「生態系」としてあらわされるものだ。  
エコシステムは、ある領域にある菌類・動物・植物などが形成する食物連鎖や有機分解などの循環を一つの系と見なすもので、ここから転じて、システム開発の分野では「ある技術において関連・相互作用・部分的変化をする、ツール・ライブラリ・他の利用Webサービスのような種類を問わない一つの技術体系」のような意味で利用される（[生態学の面から見ると誤用であるという指摘](https://togetter.com/li/1023651)や、そもそもエコシステム自体がマーケティング領域に転用され、「エコノミー(経済)システム」として取り入れられたのがテクノロジーの世界に流入してきたという説があるなど、定義が不確かな言葉ではあるが、その点には踏み込まないことにする）。

{{< figure src="https://typescriptbook.jp/assets/files/typescript-ecosystem-map-01fad23076509d150b7395ec107dc4d4.svg" width="640" title="図 2-2. TypeScriptのエコシステム" caption=" [『サバイバルTypeScript』 TypeScriptとエコシステム](https://typescriptbook.jp/overview/ecosystem)より引用。AltJS(JavaScript代替言語)の代表格であるTypeScriptのエコシステムの図示。引用元では学習コンテンツもエコシステムを形成する要素の一つとして扱っているが、エコシステムに入れるべき要素というのは定義されていないため、学習コンテンツを入れずにTypeScriptのエコシステムを紹介するものもある。エコシステムを提示する人によって要素の種類は様々である。">}}

ソフトウェアテクノロジーの領域においては、「xxxのエコシステム」という形で表現されることが多く、エコシステムの中心要素とされるものは多岐に渡る。  
例としては以下のようなものがある。

― 業務領域: Webフロントエンドのエコシステム
- プログラミング言語そのもの: JavaScriptのエコシステム
- ある言語を使う上で主流となっているツール・ライブラリ: React.jsのエコシステム
- 特定の著名SaaS: Snowflakeのエコシステム

**ソフトウェアアーキテクチャパターン** :  
アーキテクチャはソフトウェアやアプリケーションの目的を達成するために作られる構造のことだ。  
設計とアーキテクチャは何が違う？というような話題はよく出るものの、ここでは、ライブラリやツール、インターフェースなどの実態が定まっているものを設計、論理的なライブラリのカテゴリや大枠の関係性のみで構成され、実際に利用するものは選択可能な状態となっているものをアーキテクチャとして扱う。

例を挙げると、「サーバーとクライアントで構築され、クライアントはブラウザであるWebアプリケーション」という大枠の構造をアーキテクチャとすると、「*Nginx*をWebサーバー、*Gunicorn*をアプリケーションサーバーとし、アプリケーションのフレームワークとしては*Django*を利用する」というような、ユーザーや顧客の要件や要望、開発者の技術スキルや専門領域等を勘案して、最終的に実装可能な方向性まで落とし込んだのが設計、というイメージだ。

アーキテクチャは提供しようとしているシステムによって千差万別ではあるものの、部分部分を見ると、実は汎用的に利用できる論理的構造があり、それらは様々なアプリケーションやシステムに利用できる……つまり、パターン化可能であるという考え方がある。このパターンに名前をつけて、関係性や使い方、顕出しやすいメリットやデメリットなどをまとめているのがアーキテクチャパターンだ。

言葉で定義を説明すると難しく見えるが、一度でもWeb開発に携わっていれば確実にアーキテクチャパターンに触れていると言っていいだろう。例えば、*MVC*、*リポジトリ*といった単語がそうだ。

**テクノロジースタック** :  
ある目的を達成するための、技術の特定組み合わせのことを指す。日本ではテクノロジースタックという英語そのものよりも、「技術スタック」という日英混成語が使われることが多い。  
詳細な使われ方としては、概ね以下の2パターンに分けられる。

1つは、前述したアーキテクチャよりは詳細なライブラリやツールに触れるが、設計よりは個別具体的な要求に寄り添ったものではない、「すべてのケースにうまくマッチするわけではないが、一通りのユースケースに対しては対応できる」というような技術の組み合わせに使われるパターンだ。具体的には、[*LAMP*スタック](https://aws.amazon.com/jp/what-is/lamp-stack/)や、[*MEANスタック*](https://www.ibm.com/jp-ja/topics/mean-stack)といった名前の付いたスタックがこれに当たる。これらはある特定の言語における「このスタックでアプリケーションを構築・運用を数年できていれば、ある程度のアプリケーションは対応できる」という一種の技術者の力量指標に使われることがある。

もう1つは、「Stack(積み上げ)」という言葉を強調し、ある特定の企業・個人が扱っていたり、利用できる技術の総覧のことを指す。  
こちらの使われ方をする場合、すべての技術が一つの目的を達成するために連携しているわけではなく、独立した別の目的を果たすための複数の技術の組み合わせがある、ということも少なくない。

**フレームワーク** :  
フレームワークは、一般的にはなんらかの問題を解決するための手法やルールをまとめたものだが、ソフトウェア開発の領域においては、上記に挙げてきた要素を総合的に取り込み、開発者によって素早いアプリケーションの作成を支援する、一定のルールや考えのもとに作られたソフトウェアの総合基盤のことだ。

これはどういうことかを、*Java*でしばしば使われる*Spring Web MVC*というフレームワークを例に挙げて見てみよう。

*Spring Web MVC*は、*Spring Framework*という多数のフレームワークの集合の一部で、*クライアント・サーバーモデル*におけるサーバーサイドを*MVC*という**アーキテクチャパターン**に則って実装しやすくするための**フレームワーク**である。  
*Spring Web MVC*を含む*Spring Framework*は、*Spring Core*という**ライブラリ**の集合体「モジュール」を基盤とした一種の**テクノロジースタック**であり、これにより、*Spring Framework*で扱われている他のフレームワークとの組み合わせを行い、柔軟なアプリケーションの実装を手助けしている。  
また、*Spring Framework*は、*Gradle*、*Maven*といった*Java*の著名な**ビルドツール**に**プラグイン**を提供しており、Webアプリとして実行可能な形態にするビルドの**ツールチェイン**を隠蔽し、開発者が簡単にアプリケーションを作成できるような仕組みも持っている。  
一方、様々な需要に応えるために*Spring Framework*は肥大化を続け、公式だけならず、オープンソースでの**ライブラリ**や**プラグイン**の開発も多数行われ、今や*Spring Framework*の**エコシステム**は複雑かつ巨大なものとなった。  
そのため、近年では*Play Framework*のようないわゆる*マイクロフレームワーク*と呼ばれる小さな**フレームワーク**の開発が行われたり、*Spring Framework*の側でも、細かな設定値を自動的にフレームワークが吸収して設定することによって開発者の認知負荷を減らす*Spring Boot*という新たな**フレームワーク**を提供し始めるなど、*Java*の**エコシステム**にスリム化・単純化の指向を持った要素が入ってくる潮流が生まれた。

Web開発に限らず、現代の開発は多数のライブラリやツールによって成り立つエコシステムの上に成り立っていると言える。  
そして、概ねの場合、エコシステムの多くの部分を取り込み、洗練されたパラダイムやアーキテクチャパターンを実現しているフレームワークがその話題の中心となることが多い。

#### ■ トレンド

TBD

#### ■ その他には……
上記で上げた分類の語彙に直接当てはまらないが、詳細な部分を見ていくと大事な知識はまだまだある。  
おそらく、Web開発技術についてよく知る人ほど「これはどうだろう？」という単語がいくつか出てくるだろう。

例えば**認証や認可**はどうだろう？**テスト手法**は？**ライセンス管理**やAWSのような**クラウドコンピューティングのプラットフォーム**についてはどうだろう……などなど、様々な分類定義が考えられる。

確かにその通りだ。いくつか知っておいてほしいがここにはない、というものは山ほどある。  
とはいえ、「Web開発技術のあたりまえ」を知りたい人は、厳密な分類が必要というわけではないと思う。  
「だいたいのWeb開発技術についての本やWeb記事を読むうえで、何を語っているかを分類づけるには十分だ」という範囲であれば、それで良いと思わないだろうか。（そして、もしこれでも足りなさそうな分類があるとしたら意見を待っている）

今回は僕の視点から、「最も大枠で捉えられるもの」「一つの要素だけでなく、複数要素が重なり合った領域であれば説明可能であるもの」として分類した。たとえば認証・認可は大枠ではアルゴリズムとアーキテクチャパターンの組み合わせで表出するモデルであるし、認証に利用される*OpenID Connect*などの具体的な技術仕様に関してはWeb標準のモデルとしてとらえられるだろう。

---

### 「深さ」の深堀：それは「いつ」の前提知識？

前節までは「Web開発技術」という言葉が示す領域の広さを示したが、深さについても見ていこう。具体的には、どこからどこまでの時点のモデルまでを現代Web開発技術の基礎知識、つまり、ある組織や集団に限らない世間一般の規範的モデルおよび共通マインドモデルと考えるかという **「いつにおける」** の観点だ。

結論から言うと、**2015年半ばごろから2018年ごろまでの日本において、Web開発技術者に普及した新しい技術体系と考え方**、および、**2015年以前からも続く、Web技術の変わっていない基盤要素** のことを2023年における世間一般の規範的モデル（もしくは、その規範的モデルを支える前提）として選定する。

2015年は、アジャイルムーブメントから始まる理想や考えが実際の技術系統に影響を与えて萌芽し、様々な技術体系を別物と言って差し支えないほど変えていった時代だ。この時代に浸透した技術群や考え方は現代のWeb開発技術群のベースモデルとなっている。  
そのため、2023年の現代でも通用する、または前提事象となっているような知識群が大いに詰まっていると考え選定した。

以下はもっと具体的に、なぜそこをベースラインとするか、2015年を境にどのような技術がどう変わったのかという話だ。  
正直言って、かなり長いうえ、言葉の定義や歴史の話を多く含む。興味の無い人は、最後の方（具体的には、「レガシー」と「モダン」の定義の後から、図.2-4が出るところ）まで読み飛ばしてもらって構わない。

---

技術そのものの抽象や考え方といったモデルは、誰かのとらえたマインドモデルを表現したものである以上、そのモデルが表現された時世に大きく影響を受ける。例えば企業が採用する最新のコンピュータのメモリ容量が1GBもなかった時代と、どのようなコンピュータでも最低限8GBのメモリが確保され、クラウドコンピューティングが普及している時代では、良いプログラムの書き方やプロセスの進め方はまったく異なってくる。

あるものに対する「良い」の価値観の変化が起こった際、古くからある規範的モデルが時世に合わなくなり、今まではなかった課題や問題が出てくることがある。そうなった時、一部の環境で実際にそれらを解決した、および解決しそうな先進的な取り組み・概念の捉え方・考えの整理などがモデルとして現れ、モデルの中でより成果をあげたものが新たな時代の規範的モデルとして扱われることになる。  
このような規範的モデルの潮流の中で、古くからあり課題を生んでいる方を **「レガシー」** 、新たな課題を解決する方を **「モダン」** として扱うことがしばしばある。そして、多くの「レガシー」の課題点を踏まえたうえで、現代の状況によりマッチした「モダン」の方がより現代の「良い」の感覚に近いとされる。

ただし、「モダン」は良いものである可能性は高いが、先進的がゆえに、世に広まってからすぐに欠点やさらなる課題、隠れていたモデル適用の前提条件が明らかになることもある。  
一方で「レガシー」なモデルが含む要素がすべて悪かというと、そうとも言い切れない。  
むしろモダンなモデルが受けてきた批判をすでに多く受けているため、特定の前提が一致するならむしろモダンなモデルよりも扱いやすいケースも少なくないし、基盤となる思想や観点を変えずに子細なシステム要件などの状況を加味して、「最先端のモダンなモデルは知っているが、あえてレガシーに寄せる」という選択肢を取るシステムも存在する。

それに加え、実際のシステム全般では、モダンな実装や設計、開発手法のモデルがシステムに取り入れられるより、規範的モデルがマインドモデルとして人に広がる方が絶対的に早いという特徴もある。  
マイクロサービスアーキテクチャが効果的だ、ハイドレーションだ……などなど様々な新しいモデルが多々出てきているが、「モダン」なモデルが出現したあとのすべてのシステムがそういった「モダン」であり、誰も彼もがモダンなモデルに従って今時点の最高のシステムを作っているかというと、もちろんまったくそんなことはない。

レガシーとモダンの違いは、アプリケーションの設計思想や作り方を根本的に変えるものも多い。「モダンな良いモデルを学んだ！さあ実践だ！」という開発者の勢いだけで、レガシーなモデルのもとに作られたシステムに取り入れられるものではない。  
金と時間と戦略、そして、システムをモダンなものに変えるに至るビジネス上の明確な理由とが必要になる。

---

{{< figure src="/study-group-text/images/article/series-the-obvious-of-web-dev-media-02-03.png" width="640" title="図 2-3. 2022年におけるウェブサイトの各JavaScriptライブラリ利用率" caption=" [W3C Techs / 『Usage statistics of JavaScript libraries for websites』](https://internet.watch.impress.co.jp/docs/column/nettech/1107574.html)より引用。Webサイトの「レガシー」を支え、「モダン」では使われない方針が取られるjQueryも、まだまだサイトを支えるライブラリとして現役である。（メンテナンスされていない過去のサイトも含める調査なので、一概に今も使われているとは言えないが、この数値は無視することはできない）">}}

---

ここから言えることは一つ、 **単に最新のモデルを学ぶことは、特定のシステム開発に関わるすべての人の業務や作業の前提知識が揃うという目的に繋がらない可能性がある** ということだ。

正直言って、利用しているモデルがモダンかレガシーかはシステムが成功するか否かに直結するわけではない。使っているものがモダンであろうがレガシーの塊であろうが、成功するものは成功するだろう。

しかし、現代のシステム開発は、集団や組織内だけで完結するようなものでなく、世界レベルで相互関連する複雑系だ。たった一つのシステムを構成する要素が変化しただけで多重の連鎖が発生し、世界のシステム連携体制がガラッと変わり、今まで成功し続けてきたはずの自分たちのモデルが一瞬のうちにまったく成功しなくなる、という現象が起きることも大いにあり得る。  
そして、レガシーであればあるほど、そんな破壊的な変更に対応するためのコストは膨れ上がってくる。システム開発の世界では、瞬間の成功のためにアプリケーションやそれを支えるモデルがモダンである必要はないが、成功し続けるためにはモダンに追従し続ける必要があるのだ。

極端な思考実験をしてみよう。「開発用コードの保存時のストレージ利用量を1バイトでも減らすために、変数名は単一文字とするのが良い」「変数は一つだけを利用して再代入して使いまわした方がいい」ということが良いプラクティスとして認知されているWeb開発の現場があったとして（念のため言っておくが、もちろん現代ではこれらはバッドプラクティス以前の問題だ）、その現場にソースコードのバージョンコントロールシステムの使い方や概念から話して導入するのに、どれだけの時間と説得が必要だろうか？様々なモダンな技術を取り入れている組織に、開発スピードで勝ることができるだろうか？

上記は極端すぎる例（存在するかもしれないが、信じたくはない）だが、自分たちの「あたりまえ」の劣化基準を自分たちよりも広範の集団に求めないと、自分たちのレガシーの具合を判断できず、いつか来る突然死の存在すら知覚できなくなってしまう。  
よって、僕のスタンスとしては、 **絶対にアプリケーションや考え方をモダンにする必要性はないが、システムやチームの「あたりまえ」がどれくらいモダンの「あたりまえ」と離れていて、どれくらいリスクがあるかを把握するため、「一般的にモダンと扱われるもの」を「あたりまえ」を作るときの規範的モデルとした方が良い** というものとなる。

---

では、今のひとまずの「一般的なモダン」の楔をどこに打てば良いのだろうか。どの地点を対象にしてあたりまえと考えるのだろうか。

この点はかなりの争論を呼ぶところではあるが、ひとまず、僕の定義に従ってもらいたい。  
この文において、「一般的なモダン」は「僕自身が様々な視点を元にそう思ったもの」である。

……信用ならないのも仕方ないが、人間の中に絶対公平な歴史の観測者というのはいない。誰が語ったとしてもその人の視点は混ざるし、なんらかのバイアスがかかることは避けられない。  
だが、二つほど信用に足る根拠を用意してある。一つは定量的な調査、もう一つは定性的な観測結果だ。

先に定量的な調査について話そう。  
開発技術においてある程度普及したと考えられる知識体系は、しばしば認知度調査や普及の程度を見るような調査が行われている。たとえば*JavaScript*においては、[State of JavaScript](https://stateofjs.com/ja-JP/)と呼ばれる、開発者の新機能やライブラリへの調査が行われているし、もっと広い範囲で言えば、[Stackoverflowにおける開発者全体の傾向調査](https://survey.stackoverflow.co/)なんかもある。これらの調査を加味した上で選定した。

具体的には「どこかの時点で、おおよそWeb開発に関わる人間の65～70％ほどが知っている・少なくとも名前だけは聞いたことがあると思われる知識」であることを基準にした。ただし、これらの調査のアンケート対象は直接コードを書いて開発を行うような人間が多く、プログラミング言語関連の調査はさらにその言語について興味を持っている人が多いことは忘れてはならない。関連技術についての知識が豊富な人が多くなってしまい、どうしてもシステム開発に関わる人全般を母数としたものとは異なる結果となっているだろう。そのため、比率のハードルをもう少し厳しくして、 **「各年の調査において、触ったことがある・仕事で使っている・少なくとも、名前を聞いたことがあるといった人間がある時点で85％を超える技術」** にすることが妥当であるとして選定を行った。

定性的な観測結果は、僕の視点の内訳だ。  
まず僕が2023年におけるWeb開発技術の「モダン」として認識しているものを提示しておこう。  
2023年現在、Web開発技術のモダンなモデルとして扱われるものは二つあると思っている。

一つは、 **世界があらゆるWebのレガシーを捨てるという決意をした2015年以降のこと** 。  
もう一つは、**変化に対応するためのあらゆる具体例や細かなソリューション、そして、今まではなかった新たな痛みや課題が様々なアプリケーションや媒体に現れ始めた2018年前後からそれ以降のこと**だ。  
これら二つのモダンは、どちらも現実・ビジネスシーンの素早い変化に対応するという目的が共通しており、この共通点をもってまとめて一つのモダン傾向と扱われることが多い。[^7]

[^7]: "モダンアプリケーションとは素早いイノベーションによって競争的差別化を作り出す⼿段となるもの" [AWS Summit Online 2021 『コンテナ・サーバーレスを使えばモダンアプリケーションになりますか︖』](https://d1.awsstatic.com/events/jp/2021/summit-online/AWS-27_AWS_Summit_Online_2021_MAD01.pdf) p.12 濱 真⼀

一つ目のモダンへの大きな転機は、 **ECMAScript 2015のリリース**と、**Windows 10のリリース、およびそれに伴うWindowsの標準ブラウザの置き換え** 、そして、**コンテナ技術の普及のはじまり**だ。

これらの出来事は主にJavaScriptに影響するものだ。ECMAScript 2015はJavaScriptの仕様面での大きな変更、標準ブラウザの置き換えは、すなわち独自のブラウザ実装およびJavaScript実装を積み上げてきたInternet Explorerの実質的な非推奨化となっている。JavaScript自体が当時Webのプラットフォームとして大きな存在感があったということもあるが、それに加えてシステム開発に対して目に見えない大きなインパクトもあった。

当時、Flashの最後の砦だったInternet Explorerの事実的廃止が決まり、JavaScriptはWebの動的コンテンツを支える唯一の巨大基盤になっていた。しかし、古くからある仕様と新しい仕様の氾濫による混乱や、様々なブラウザ実装の差異などもあり、実装においても設計においても共通して利用できるような、いわゆる標準と言えるものをどこに合わせていいのかわからない混乱期にあった。

このような混乱期は2015年以前から数年にもわたって続いていたが、ついに一定基準の標準がリリースされたこと、加えて、このあたりから変化やバージョンアップのサイクルが数年単位から1年～2年ごとの定期的なアップデート体制へと変化していったこと、そして、ECMAScript 2015に合わせて、ES Modulesと呼ばれるフロントエンドのモジュール管理仕様の整備が行われたことなどは、システム開発の世界に大きく影響を与えたように思える。  
現実の変化の速さに対応するために、Webに限らない様々なツールやライブラリが変化・アップデートのスピードを上げ始めた。また、もはや非推奨となる技術のサポートを独自に続けていた技術でさえ、明らかにサポートを切り捨て始めたのもこの時期だと認識している。

Dockerに代表されるコンテナ仮想化技術が一部の研究的利用から製品投入へのプロセスを経て、一般的な普及・利用パターンの整備が進んだのもこのころになる。  
コンテナによって、今までアプリケーションレベルの範囲のみを開発範囲としていく開発者の仕事の進め方が、もっと広範、いわゆるインフラと呼ばれるレイヤーも含めたものを対象としていくような空気が漂い始めた。  
それに加え、フロントサイドではAngularやReactやVueを代表とした宣言的UIの普及、npm, Webpackなどのフロントエンドビルドツールの発展など、とにかくこの時期の前後にWebに起きた変化とその普及は多岐にわたる。

2015年ごろの技術の変化に伴う構造や考え方などは、2023年現在に至るまでのWeb開発技術のベースラインを完全に変えた。特に2018年までに培われた実践例の蓄積と改善は、もはやレガシーとモダンの差を隔絶といっていいほど大きく広げた。よって、この段階を一つの「モダン」が成立した時期と考えてよいだろう。[^8]

[^8]: 2010年初期ごろからRuby on Railsが流行し、フロントエンドの不満点が溜まっていき、それがこのころ爆発した、という話も聞くが、筆者がRailsの方面にあまり詳しくないこと（一応2017年ごろに一度触ってみたが、Railsのフロントエンドをどうするかの混乱期にあったので古めのgemのエコシステムに乗って触っていた）、また、筆者がエンジニアとしてのキャリアを始めたのがこのころであまり実感を持って語れないことのため、本文内では触れないこととした。[このへん](https://blog.unasuke.com/2020/i-have-to-learn-those-things-in-the-future/)や[このへん](https://zenn.dev/mizchi/articles/d33a4174cca886)を参照。RailsのWebに与えた影響として、他にはいわゆる[「設定より規約(Convention over Configuration)」](https://arison.jp/blog/2012/05/15/convention-over-configuration/)や[「Opinionated」](https://izumisy.work/entry/2019/07/10/112315)といったZero Configurationへ向かう思想がサーバーサイド・バックエンドに大きな影響を与え、様々なフレームワークが規約ベースとなっていき、それがのちのちフロントサイドのライブラリやフレームワークにも少しずつ浸透していく……といった流れがあるように思えるが、これも同様の理由かつ、フレームワークの詳細な思想は今回の主旨に合わないので触れないことにする。

二つ目のモダンに関しては、技術がけん引したというよりは、むしろプロセスや考え方の転換だと言える。こちらのキーワードは **DevOps**、すなわち、開発と運用の協調と実質的な統合にある。  
また、こちらの方は第一のモダンのようなわかりやすい転機があるわけではなく、ゆっくりと浸透するように広がってきたものだ。強いて言えば、[『Site Reliability Engineering: How Google Runs Production Systems』](https://www.amazon.co.jp/dp/4873117917)、通称SRE本の出版が一つの転機だろうか。

DevOpsという言葉自体は、開発と運用という、いわばシステムを作る部門と動かす部門と業務が分かれた分業化を行うことよりも、統合されたプロセスによる迅速で確実なリリースを進める、というものだ[^9]。第一のモダンの発展の時期よりも前に出てきた概念ではあるが、第一のモダンの発展により、理論から実現へと大きく歩を進めた。  
また、SREはGoogleが提唱した一つのDevOpsの実践プロセスや方法論で、しばしば「DevOpsは抽象クラスのようなもので、SREはDevOpsを実行するためのGoogle製の実装」とも言われる。

[^9]: DevOpsについて一言で表すのは難しいため、かなり曖昧に表現した。考え方やツールやプラクティスがあまりにも多すぎるので、今回はこの分野には詳しく触れない。詳細は各自で調べてほしい。DevOpsに関わる本は多くあるが、特に開発者が理解を進める際に有用な本として、本文にあげた『サイトリライアビリティエンジニアリング ―Googleの信頼性を支えるエンジニアリングチーム』だけでなく、[『LeanとDevOpsの科学 テクノロジーの戦略的活用が組織変革を加速する』（原著『Accelerate』）](https://www.amazon.co.jp/dp/4295004901)を特に推奨する。現在Googleが定期的にDevOpsについて調査報告しているState of DevOps Reportの調査チーム（というか、Nicole Forsgrenを中心としたDORA社）が行った調査やその結果をまとめた本になっている。

第一のモダンの発展時期に出てきた様々な技術は、システムを作ることのコストを大幅に下げた。しかし、同時に作ったものを動かし続けることの痛みと難しさもそれと同時に広く認識されることとなった。開発部署が既存タスクのコスト減により、より幅広いシステムの業務に関わるようになり、今まで運用部署に放り投げてきた業務責任が、プロセスの責任範囲を広げた開発部署にまで及ぶようになった。同時に運用部署も、設計初期から関わらなければ運用そのものが成り立たないという現実が明らかになってきたのだ。

その中で着目されてきたのがDevOpsおよびSREというモデルだ。2018年以前にも、DevOpsという言葉は開発と運用の統合・新たな職務や作業プロセスや概念を統合するモデルとして存在してきてはいたが、実際にDevOpsが解決しそうな直面の課題や現実的な悩みとしての浸透、および、GoogleによるSRE本の発売、そして、[DORAによるState of DevOps Report](https://dora.dev/)によるDevOpsの生産性向上効果の可視化により、多くのシステム開発関係者に浸透することとなった。[^10]

[^10]: DevとOpsの責任範囲が異なることによる分断とそれに伴うアプリケーションの停滞、また、それらを解消するためのDevOpsという概念は、2018年以前、もっと言うなら2010年代初期ごろにはすでに存在したし、それにともなうコミュニティや、実例やプラクティスなどを紹介する本もあった（[Gene Kimの『The Phoenix Project:A Novel About IT, DevOps, and Helping Your Business Win』](https://www.amazon.co.jp/dp/0988262592)が代表。というか、このDevOpsの流行経緯はGene Kimのモデル提示の歴史と言っても過言じゃないかもしれない）。が、2015年ごろまでの日本ではあくまで「エンジニアが勝手に良いぞと言い始めた、それっぽい理想論の集合体」くらいに扱われていたように見ている。爆発的に普及したきっかけは、それらのプラクティス効果の可視化が始まった2018年ごろからであったとして扱っている。また、開発側から見る歴史であるため、運用視点から見ると爆発的に広がったと思われる時期や、きっかけなどが違うかもしれない。再三ではあるものの、ここでは、あくまで僕がそうとらえているというつもりで見ていただきたい。

---

{{< figure src="/study-group-text/images/article/series-the-obvious-of-web-dev-media-02-04.png" width="640" title="図 2-4. DevOpsが生産性へ与えるインパクト" caption="[Takuto Wada / 『組織に自動テストを書く文化を根付かせる戦略（2022秋版）』](https://speakerdeck.com/twada/building-automated-test-culture-2022-autumn-edition?slide=27)より引用。強烈なインパクトのある数字だが、スライドを続けて読むとさらにインパクトが大きくなる。">}}

---

現代のモダンなWeb開発技術として位置づけられているものは、概ねこの2つのモダンを前提としている。そして、これらのモダンの軸となるのは、「素早い変化と要求の変更に対応するための、開発スタンスの根本的な変更」、いわゆるアジャイルと呼ばれるムーブメントだ。  
この2つはどちらも重要な潮流ではあるが、本文で扱うものは **前者のモダンとしているもの、つまり、2015年ごろから浸透した技術体系から、DevOpsなどの開発と運用との協働を扱うものを除いたもの** とする。

理由は簡単で、2018年からの運用のモダン化は、2015年からの開発のモダン化の内容を前提にしたものを大いに含むからだ。  
特に2018年以降のモダン化において多くの割合を占めている CI/CD[^11] の達成のためには、ソースコードのコミットから自動テストとビルドを行う必要があるが、これに2015年以前のツールや考え方を利用すると、逆にコストが膨れ上がることとなる。

[^11]: *Continuous Integration* ・ *Continuous Deployment* の略称。日本語ではそれぞれ、「継続的インテグレーション」「継続的デプロイメント」とされる。様々な手法を用いて、アプリケーションのリリースの頻度を高める考え方・プラクティス・自動化手法そのもののこと。

もちろん、ここでは扱わないとはいえ、どちらのモダンも大切なのは間違いない。  
規範的モデルとして採用できる要素があるならば、どんどん取り入れていこう。

---

## ここでは扱わないもの

モダンなWeb開発技術として一部扱わないものがあることを前述したが、ここでは他にも扱わないものがある。  
近年ではしばしば **「ドメイン」** もしくは **「ビジネスドメイン」** という名称で扱われるものだ。

エンジニアリングにおける知識は、大まかにわけると「ドメイン」と「テクノロジー」の領域がある。  
ドメインは[Eric Evansの『Domain-Driven Design』(2003年出版)](https://www.amazon.co.jp/dp/0321125215)を由来とする単語で、ソフトウェアやアプリケーションが解決する業務対象を指す単語だ。「無限の人的リソースと時間があれば、テクノロジーがなくとも業務達成可能となる知識」と考えてもいいだろう。

例えば、データ分析の仕事を考えてみよう。統計学の知識（ドメイン）がわかっていればデータ表からヒストグラムの作成と標準偏差を紙に書き、人に渡すことで、テクノロジーやシステムがなくとも業務達成は可能となる。しかし、そのためにデータを一つ一つ抜き出し、間違いがないように計算を行うことは現実的ではない。100万件のデータを扱うのに50年かかるようでは現代ならずいつであっても遅すぎる。  
テクノロジーは、これを有限のリソースと現実的な時間に納めるための技術となる。

もっと言えば、「特定ドメインにおいてのみ使われるテクノロジー」もある。  
例えば、地理空間情報を扱うシステムでは **GeoJSON** というフォーマットがしばしば登場する。これはJSONの一種ではあるが、構造やメンバー名などが固定されているというフォーマットだ。このフォーマットを採用することによって、違う経緯や背景で作られたシステム同士でも、同様の地理空間情報を扱うことができ、異なるシステム同士の連携性能を高めることができる。

このようなあるドメインにのみ利用されるようなテクノロジーの知識は、確かに一部の業界では基本的な知識として扱われるだろう。  
だが、これは「ドメイン」と見なし、扱わないこととする。

理由としては二つある。  
まず、「一般的なモダン」として定義した条件「各年の調査において、触ったことがある・仕事で使っている・少なくとも、名前を聞いたことがあるといった人間がある時点で85％を超える技術」に該当しないからだ。  
人類全体が所属する業界を見た際に、85％を越える人が従事している業界なんてものなどないし、存在するとしたらそれはわざわざここで紹介する必要もないほどわかりきったこと（たとえば、「この文章における読者とは、2023年現在地球上に住んでいる人類のことを指し、火星人やネアンデルタール人については対象外とする」とか）や、後述する「ソフトスキル」にあたるものだろう。

二つ目の理由としては、このような複数領域が重なっている知識を扱うには、そもそもテクノロジーを知っておかないといけないからだ。  
上記のGeoJSONは、そもそもJSONの拡張フォーマットなので、JSONというテクノロジー領域の適切な扱いがわかってないと、適切に扱えることなどない。

{{< figure src="/study-group-text/images/article/series-the-obvious-of-web-dev-media-02-05.png" width="640" title="図 2-5. 本シリーズで扱う領域イメージ" >}}

また、もう一つ扱わないものもある。いわゆる **「ソフトスキル」** と呼ばれるものだ。  
ソフトスキルは、何の業務・作業に関わっているかに拠らず、すべての職業・役割に適用されるスキルのことで、プレゼンテーションやドキュメントの作成、情報共有におけるコミュニケーションに対するスキルを含むものだ。[^12] 「社会人の教養」と言い換えても良いだろう。

[^12]: [Academic Accelerator / Soft Skills](https://academic-accelerator.com/encyclopedia/jp/soft-skills)より "ソフトスキルは、パワースキル、共通スキル、コアスキルとも呼ばれ、すべての職業に適用されるスキルです。これらには、批判的思考、問題解決、人前で話すこと、専門的な文章、チームワーク、デジタルリテラシー、リーダーシップ、職業上の態度、労働倫理、キャリア管理、異文化間の流暢さが含まれます。" ソフトスキル以外のスキルとして、職責に準じた専門的な知識である「ハードスキル」や、ソフトスキルとハードスキルをうまく融合させて扱うなど、スキルそのものを扱う知識である「メタスキル」が存在する。

近年のシステム開発は、一人のエンジニアがすべてをまかなう「職人芸」の世界から、チームプレイの世界へと変化してきている。そんな中、ありとあらゆる背景を持つ人間と協調し、共に働くためのソフトスキルがより重視される世界になってきている。

この背景から、ソフトスキルも一般的なモダンなモデルとして扱われても良い範囲ではあるが、こちらはより一般的に適用されるスキルのため、言葉や形を変えて解説している書籍が多い。
わざわざここで紹介するのではなく、他の書籍で探索を行った方が良いと考え扱わないことにした。（特にアプリケーション開発者に関しては、[『SOFT SKILLS』というそのもののタイトルの本もある](https://www.amazon.co.jp/dp/4822251551)）

つまりこうだ。 **このシリーズでは開発におけるハードスキルのみを扱う。ただし、特定業界や特定目的のビジネスドメインに依存するようなハードスキルを除き、普遍的に利用されるものだけを扱うこととする。**
